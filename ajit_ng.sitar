module Top
    submodule_array cpu[1]: CPU_CORE<2>
    submodule bridge : Bridge<1>
    submodule memory : Memory

    // CPU_CORE <-> Bridge
    net_array m_request_type[1] : capacity 1  width 8
    net_array m_byte_mask[1] : capacity 1  width 8
    net_array m_addr[1] :  capacity 1 width 32
    net_array m_data64[1] :  capacity 1 width 64
    net_array  m_rdata[1] :  capacity 1 width 64    

    // Bridge <-> Memory
    net m_address : capacity 1 width 32
    net double_word:  capacity 1 width 64
    net mem_byte_mask:  capacity 1 width 8
    
    net m_data:  capacity 1 width 64
	
	// Bridge → D$ broadcasts
    net_array  br2dc_inv_paddr_line_net[1] : capacity 1 width 32   // physical line address
	
	// Bridge → I$ broadcasts
    net_array  br2ic_inv_paddr_line_net[1] : capacity 1 width 32   // physical line address
    
    for i in 0 to 0
        cpu[i].request_type => m_request_type[i]
        cpu[i].byte_mask => m_byte_mask[i]
        cpu[i].addr => m_addr[i]
        cpu[i].data64 => m_data64[i]
        cpu[i].rdata <= m_rdata[i]
        
        bridge.request_type[i] <= m_request_type[i]
        bridge.byte_mask[i] <= m_byte_mask[i]
        bridge.addr[i] <= m_addr[i]
        bridge.data64[i] <= m_data64[i]
        bridge.rdata[i] => m_rdata[i]
		
		cpu[i].br2dc_inv_paddr_line <= br2dc_inv_paddr_line_net[i]
		bridge.br2dc_inv_paddr_line[i] => br2dc_inv_paddr_line_net[i]
		cpu[i].br2ic_inv_paddr_line <= br2ic_inv_paddr_line_net[i]
		bridge.br2ic_inv_paddr_line[i] => br2ic_inv_paddr_line_net[i]
    end for
    
    bridge.m_address => m_address
    bridge.double_word => double_word
    bridge.m_byte_mask => mem_byte_mask
    bridge.m_data <= m_data
    
    memory.m_address <= m_address
    memory.double_word <= double_word
    memory.m_byte_mask <= mem_byte_mask
    memory.m_data => m_data
    
end module


module CPU_CORE
    parameter int CPU_THREADS = 2
    // CPU_CORE <-> Bridge
    outport request_type : width 8
    outport byte_mask : width 8
    outport addr : width 32
    outport data64 : width 64
    inport  rdata : width 64
	
	// Bridge → D$ broadcasts
    inport  br2dc_inv_paddr_line : width 32   // physical line address
	
	// Bridge → I$ broadcasts
    inport  br2ic_inv_paddr_line : width 32   // physical line address
    
    submodule_array cpu[CPU_THREADS] : CPU_CORE_THREAD<12>    	//Instantiate a memory module with <size=2 MB,delay=10>
    submodule dcache : DCACHE<2>
    submodule icache : ICACHE<2>
    submodule mmu : MMU<0>
    
    net_array d_asi[CPU_THREADS] : capacity 1 width 8
    net_array d_addr[CPU_THREADS] : capacity 1 width 32
    net_array d_request_type[CPU_THREADS] : capacity 1 width 8
    net_array d_byte_mask[CPU_THREADS] : capacity 1 width 8
    net_array d_write_data[CPU_THREADS] : capacity 1 width 64
    net_array d_mae[CPU_THREADS] : capacity 1 width 8
    net_array d_read_data[CPU_THREADS] : capacity 1 width 64    
    
    net_array	i_asi[2]: capacity 1 width 8
    net_array i_addr[2]: capacity 1 width 32
    net_array i_request_type[2]: capacity 1 width 8
    net_array i_byte_mask[2]: capacity 1 width 8
    net_array i_mae[2]: capacity 1 width 8
    net_array inst_pair[2]: capacity 1 width 64
	net_array i_mmu_fsr[2]: capacity 1 width 32
    
    // D$ <-> MMU
    net dm_mmu_command: capacity 1 width 8
    net dm_request_type: capacity 1 width 8
    net dm_asi: capacity 1 width 8
    net dm_addr: capacity 1 width 32	
    net dm_byte_mask: capacity 1 width 8 
    net dm_write_data: capacity 1 width 64

    net dm_mae: capacity 1 width 8 
    net dm_cacheable: capacity 1 width 8 
    net dm_acc: capacity 1 width 8
    net dm_read_data: capacity 1 width 64
    net dm_read_line: capacity 1 width 512
    net dm_mmu_fsr: capacity 1 width 32
    net dm_synonym_invalidate_word: capacity 1 width 32
    
    // I$ <-> MMU
    net im_mmu_command: capacity 1 width 8
    net im_request_type: capacity 1 width 8
    net im_asi: capacity 1 width 8
    net im_addr: capacity 1 width 32	
    net im_byte_mask: capacity 1 width 8 

    net im_mae: capacity 1 width 8 
    net im_cacheable: capacity 1 width 8 
    net im_acc: capacity 1 width 8
    net im_read_data: capacity 1 width 64
    net im_read_line: capacity 1 width 512  
    net im_mmu_fsr: capacity 1 width 32
    net im_synonym_invalidate_word: capacity 1 width 32
    
    // CPU_CORE <-> Bridge
    net m_request_type : capacity 1  width 8
    net m_byte_mask : capacity 1  width 8
    net m_addr :  capacity 1 width 32
    net m_data64 :  capacity 1 width 64
    net  m_rdata :  capacity 1 width 64    
    
	// Bridge → D$ broadcasts
    net  br2dc_inv_paddr_line_net : capacity 1 width 32   // physical line address
	
	// Bridge → I$ broadcasts
    net  br2ic_inv_paddr_line_net : capacity 1 width 32   // physical line address
    
    for i in 0 to (CPU_THREADS - 1)
        
        // CPU and D Cache

        cpu[i].d_asi => d_asi[i]
        cpu[i].d_addr => d_addr[i]
        cpu[i].d_request_type => d_request_type[i]
        cpu[i].d_byte_mask => d_byte_mask[i]
        cpu[i].d_write_data => d_write_data[i]
        cpu[i].d_mae_in <= d_mae[i]
        cpu[i].d_read_data <= d_read_data[i]
        

        dcache.asi[i] <= d_asi[i]
        dcache.addr[i] <= d_addr[i]
        dcache.request_type[i] <= d_request_type[i]
        dcache.byte_mask[i] <= d_byte_mask[i]
        dcache.write_data[i] <= d_write_data[i]
        dcache.mae_out[i] => d_mae[i]
        dcache.read_data[i] => d_read_data[i]
        
        // CPU and I Cache

        cpu[i].i_asi => i_asi[i]
        cpu[i].i_addr => i_addr[i]
        cpu[i].i_request_type => i_request_type[i]
        cpu[i].i_byte_mask => i_byte_mask[i]
        cpu[i].i_mae_in <= i_mae[i]
        cpu[i].inst_pair <= inst_pair[i]
        cpu[i].i_mmu_fsr <= i_mmu_fsr[i]
        
        icache.asi[i] <= i_asi[i]
        icache.addr[i] <= i_addr[i]
        icache.request_type[i] <= i_request_type[i]
        icache.byte_mask[i] <= i_byte_mask[i]
        icache.mae_out[i] => i_mae[i]
        icache.inst_pair[i] => inst_pair[i]
        icache.mmu_fsr[i] => i_mmu_fsr[i]
		
    end for

    // D$ <-> MMU
    dcache.dm_mmu_command => dm_mmu_command
    dcache.dm_request_type => dm_request_type
    dcache.dm_asi => dm_asi
    dcache.dm_addr => dm_addr	
    dcache.dm_byte_mask => dm_byte_mask 
    dcache.dm_write_data => dm_write_data

    dcache.dm_mae <= dm_mae 
    dcache.dm_cacheable <= dm_cacheable 
    dcache.dm_acc <= dm_acc
    dcache.dm_read_data <= dm_read_data
    dcache.dm_read_line <= dm_read_line
    dcache.dm_mmu_fsr <= dm_mmu_fsr
    dcache.dm_synonym_invalidate_word <= dm_synonym_invalidate_word

    mmu.dm_mmu_command <= dm_mmu_command
    mmu.dm_request_type <= dm_request_type
    mmu.dm_asi <= dm_asi
    mmu.dm_addr <= dm_addr	
    mmu.dm_byte_mask <= dm_byte_mask 
    mmu.dm_write_data <= dm_write_data

    mmu.dm_mae => dm_mae 
    mmu.dm_cacheable => dm_cacheable 
    mmu.dm_acc => dm_acc
    mmu.dm_read_data => dm_read_data
    mmu.dm_read_line => dm_read_line
    mmu.dm_mmu_fsr => dm_mmu_fsr
    mmu.dm_synonym_invalidate_word => dm_synonym_invalidate_word
    
    // I$ <-> MMU
    icache.im_mmu_command => im_mmu_command
    icache.im_request_type => im_request_type
    icache.im_asi => im_asi
    icache.im_addr => im_addr	
    icache.im_byte_mask => im_byte_mask 

    icache.im_mae <= im_mae 
    icache.im_cacheable <= im_cacheable 
    icache.im_acc <= im_acc
    icache.im_read_data <= im_read_data
    icache.im_read_line <= im_read_line

    icache.im_mmu_fsr <= im_mmu_fsr
    icache.im_synonym_invalidate_word <= im_synonym_invalidate_word

    mmu.im_mmu_command <= im_mmu_command
    mmu.im_request_type <= im_request_type
    mmu.im_asi <= im_asi
    mmu.im_addr <= im_addr	
    mmu.im_byte_mask <= im_byte_mask 

    mmu.im_mae => im_mae 
    mmu.im_cacheable => im_cacheable 
    mmu.im_acc => im_acc
    mmu.im_read_data => im_read_data
    mmu.im_read_line => im_read_line

    mmu.im_mmu_fsr => im_mmu_fsr
    mmu.im_synonym_invalidate_word => im_synonym_invalidate_word
    
    // CPU_CORE <-> Bridge
    mmu.request_type => m_request_type
    mmu.byte_mask => m_byte_mask
    mmu.addr => m_addr
    mmu.data64 => m_data64
    
    mmu.rdata <= m_rdata    

    request_type <= m_request_type
    byte_mask <= m_byte_mask
    addr <= m_addr
    data64 <= m_data64
    
    rdata => m_rdata
	
	br2dc_inv_paddr_line => br2dc_inv_paddr_line_net
	dcache.br2dc_inv_paddr_line <= br2dc_inv_paddr_line_net
	br2ic_inv_paddr_line => br2ic_inv_paddr_line_net
	icache.br2ic_inv_paddr_line <= br2ic_inv_paddr_line_net
		
end module
    
module CPU_CORE_THREAD
	parameter int CORE_ID = 0
	parameter int CPU_ID = 0
    parameter int THREAD_ID = 0
	parameter int isa_mode = 32
	parameter int bp_table_size = 16
	parameter int report_traps = 0
    parameter int init_pc = 0

    //defne ports for D Cache
    outport	d_asi : width 8
    outport d_addr : width 32
    outport d_request_type : width 8
    outport d_byte_mask : width 8
    outport d_write_data : width 64
    inport d_mae_in : width 8
    inport d_read_data : width 64    

    //define ports for I cache
    outport	i_asi : width 8
    outport i_addr : width 32
    outport i_request_type : width 8
    outport i_byte_mask : width 8
    inport i_mae_in : width 8
    inport inst_pair : width 64
	inport i_mmu_fsr : width 32
    
    include $extern "C" {
		#include "string.h"
		#include "ajit_ng.h"	
		#include "Ancillary.h"
		#include "RegisterFile.h"
		#include "Decode.h"
		#include "Flags.h"
		#include "Opcodes.h"
		#include "ThreadLogging.h"
		#include "Traps.h"
		#include "AjitThreadS.h"
		#include "ThreadInterfaceS.h"
		#include "ExecuteS.h"
    }
	$


    //include $extern void init_cpu();$
    //include $extern void cpu();$
    //include $extern thread_local state current_state;$
    decl $uint8_t mae, done_pull, d_done_pull, i_done_pull, skip_fetch, wait_4_cache;$
    decl $uint64_t dcache_read_data;$
    decl $token<sizeof(uint8_t)*8> mae_token, d_mae_token, i_mae_token;$
	decl $token<sizeof(uint64_t)*8> read_data_token;$
	decl $ThreadState* thread_state;$
	decl $dcache_out dc_out ;$
	decl $icache_out ic_out;$
	decl $dcache_in dc_in;$
	decl $icache_in ic_in;$
	decl $int is_buffer_hit;$
	decl $uint8_t post_fetch_trap;$
	decl $InstructionType inst_type;$
	decl $Opcode opcode;$
	decl $uint32_t operand1_0,operand1_1,operand1_2,operand1_3,operand2_0,operand2_1,operand2_2,operand2_3, result_h, result_l;$
	decl $uint8_t rd, asi, rs1, rs2, shcnt, software_trap, i , a;$
	decl $uint8_t flags;$
	decl $uint16_t simm13;$
	decl $uint32_t disp30, disp22;$
	decl $uint32_t data0, data1;$
	decl $uint8_t vector_data_type;$
	decl $uint8_t skip_execute, skip_fp_execute;$
	decl $uint32_t post_execute_trap_vector;$
	decl $uint8_t save_flag;$
	decl $uint8_t restore_flag;$

behavior
	$

	opcode = _UNASSIGNED_;
	inst_type = _UNKNOWN_;

	operand1_0 = operand1_1 = operand1_2 = 
			operand1_3 = operand2_0 = operand2_1 = operand2_2 = operand2_3 = 0;
			
	
	dc_out = { (void *) &d_asi, (void *) &d_addr, (void *) &d_request_type, (void *) &d_byte_mask, (void *) &d_write_data, (void *) &d_read_data, \
											0,0,0,0, 0, 0, 0, 0, 0, 0, 0,0,0,0, 0, 0, 0, 0};
	ic_out = {(void *) &i_asi, (void *) &i_addr, (void *) &i_request_type, (void *) &i_byte_mask, 0, 0, 0, 0, 0};
    dc_in = {(void *)&d_mae_in, (void *)&d_read_data};
	ic_in = {(void *)&i_mae_in, (void *)&inst_pair, (void *)&i_mmu_fsr };

    thread_state = makeThreadState(CORE_ID, THREAD_ID, isa_mode, bp_table_size, report_traps, (uint32_t)init_pc);
	
    $;

	do
        
        $
		thread_state->addr_space = (getBit32(thread_state->status_reg.psr, 7) == 0) ? 8 : 9; // Supervisor bit

		skip_fetch = !(thread_state->mode == _EXECUTE_MODE_);
		// Only MAE trap from fetchInstruction
		post_fetch_trap=0;
		
		thread_state->mmu_fsr = 0;
		$;
        
		if (skip_fetch == 0) then // use the sitar if
		
			$
			//clear register-update flags 
			//(which maintain information for logging)
			//at the start of this instruction cycle.
			clearStateUpdateFlags(thread_state);
			thread_state->reg_update_flags.pc = thread_state->status_reg.pc;
			
			ic_out.mae = 0;
			ic_out.push_done = 0;
			is_buffer_hit = fetchInstruction_split_1(thread_state, thread_state->addr_space, thread_state->status_reg.pc, &ic_out ); //memory_read            
			done_pull = 0;
			$;
			
			if (is_buffer_hit == 0) then // this is a sitar if
				do
					wait until (this_phase==0);
					$done_pull=i_mae_in.pull(mae_token);$;
					if(not done_pull) then wait end if;
				while(not done_pull) end do;   
				wait until (this_phase==1);
				$memcpy(&ic_out.mae, mae_token.data(), sizeof(uint8_t));$;
			end if;

			$

			post_fetch_trap = fetchInstruction_split_2(thread_state, thread_state->status_reg.pc, &(thread_state->instruction),
									&(thread_state->mmu_fsr),&ic_out, &ic_in); //memory_read

			//================================
			//increment count of instructions fetched
			(thread_state->num_ifetches)++;
            
            
			if((thread_state->reporting_interval > 0) && ((thread_state->num_ifetches)%(thread_state->reporting_interval)==0) )
			{
				fprintf(stderr,"\n==============================================\n");
				//fprintf(stderr,"Real time = %s\n",ctime(&simulation_time));
				//fprintf(stderr,"Cycle-count estimate = %lu\n",getCycleEstimate(thread_state));
				fprintf(stderr,"num_ifetches = %lu\n",thread_state->num_ifetches);
				fprintf(stderr,"num_traps = %u\n",thread_state->num_traps);
				fprintf(stderr,"PC=0x%x\n",thread_state->status_reg.pc);
				fprintf(stderr,"nPC=0x%x\n",thread_state->status_reg.npc);
				fprintf(stderr,"trap_vector=0x%x\n",thread_state->trap_vector);
				fprintf(stderr,"==============================================\n");
			}

			//================================

			thread_state->trap_vector = setBit32(thread_state->trap_vector, _MAE_, post_fetch_trap);
			#ifdef DEBUG
			fprintf(stderr,"Fetched instruction 0x%x at PC = 0x%x\n",thread_state->instruction, thread_state->status_reg.pc);
			#endif

			// update mmu fsr, far
			// This is done separately to match the behaviour of
			// the instruction pipeline.
			$;
			
			if(thread_state->mmu_fsr != 0) then // Lets make this a sitaar if
			
				$
				updateMmuFsrFar_push(thread_state->mmu_fsr, thread_state->status_reg.pc, &dc_out);

				done_pull = 0;
				$;
			    
				do
					wait until (this_phase==0);
					$done_pull= d_mae_in.pull(mae_token);$;
					if(not done_pull) then wait end if;
				while(not done_pull) end do;				
				wait until (this_phase==1);
				
				$
				done_pull = d_read_data.pull(read_data_token);
				assert(done_pull != 0);
				memcpy(&dcache_read_data, read_data_token.data(), sizeof(uint64_t));
                $;
			end if;
		end if;

		$
		uint8_t annul_trap = getBit32(thread_state->trap_vector, _ANNUL_);
		uint8_t update_post_fetch_trap = !skip_fetch && post_fetch_trap && !annul_trap;

		if(update_post_fetch_trap)
		{
			thread_state->trap_vector = setBit32(thread_state->trap_vector, _TRAP_, 1);
			thread_state->trap_vector = setBit32(thread_state->trap_vector, _INSTRUCTION_ACCESS_EXCEPTION_, 1);
		}

		uint8_t annul_inst = !skip_fetch && annul_trap; //Annul the current instruction
		
		if(annul_inst)
		{
			thread_state->trap_vector    =  setBit32(thread_state->trap_vector, _ANNUL_, 0) ;
			thread_state->status_reg.pc  =  thread_state->status_reg.npc ;
			thread_state->status_reg.npc =  thread_state->status_reg.npc + 4 ;
			#ifdef DEBUG
			fprintf(stderr,"\tcurrent instruction is annulled\n");
			#endif

		}

		uint8_t skip_decode = skip_fetch || post_fetch_trap || annul_trap;

		//if(!skip_decode)
		//{
		//	inform_HW_server(thread_state, GDB_IFETCH, 0);
		//}

		uint8_t fp_uimp_inst = 0;
		uint8_t fp_invalid_reg = 0;	//to check fp_invalid_reg exception

		if(!skip_decode)
			decodeInstruction(thread_state->instruction, thread_state->isa_mode,
						&opcode, 
						thread_state->trap_vector, 
						&rs1, &rs2, &simm13, 
						&shcnt, &disp30, 
						&disp22, &software_trap, 
						&rd, &i, &a, &asi, &inst_type, 
						&fp_uimp_inst, &vector_data_type);

		// Generating Invalid_FP_Register trap
		if(fp_uimp_inst) {
			thread_state->trap_vector = setBit32(thread_state->trap_vector, _TRAP_, 1) ;
			thread_state->trap_vector = setBit32(thread_state->trap_vector, _FP_EXCEPTION_, 1) ;
			thread_state->status_reg.fsr = setSlice32(thread_state->status_reg.fsr, 16, 14, _UNIMPLEMENTED_FPOP_);
		}

		flags = 0;
		flags = ((a == 1) ? setBit8(flags, _ANNUL_FLAG_, 1) : flags);

		uint8_t cwp = getSlice32(thread_state->status_reg.psr, 4, 0);
		if(!skip_decode)
			readOperands(thread_state->register_file,
					opcode, rs1, rs2, rd, simm13, shcnt, 
					disp30, disp22, software_trap, i, &operand2_3, &operand2_2,
					&operand2_1, &operand2_0, &operand1_3, &operand1_2, 
					&operand1_1, &operand1_0, inst_type, cwp, 
					&data1, &data0, &fp_invalid_reg);

		// Generating Invalid_FP_Register trap
		if(fp_invalid_reg) {
			thread_state->trap_vector = setBit32(thread_state->trap_vector, _TRAP_, 1) ;
			thread_state->trap_vector = setBit32(thread_state->trap_vector, _FP_EXCEPTION_, 1) ;
			thread_state->status_reg.fsr = setSlice32(thread_state->status_reg.fsr, 16, 14, _INVALID_FP_REGISTER_);
		}

		uint8_t is_fp_op = (inst_type == _FPop1_INS_) || (inst_type == _FPop2_INS_);

		skip_fp_execute = (skip_decode || !is_fp_op);
		uint32_t post_fp_execute_trap_vector = 0;
		if(!skip_fp_execute)
		{
			post_fp_execute_trap_vector = 
				completeFPExecution(thread_state,  opcode, 
						operand2_3, operand2_2, operand2_1, operand2_0,  
						operand1_3, operand1_2, operand1_1, operand1_0, 
						rd, &(thread_state->status_reg), thread_state->trap_vector);
			thread_state->trap_vector = post_fp_execute_trap_vector;
		}

		skip_execute = (skip_decode || is_fp_op);
		post_execute_trap_vector = 0;

		save_flag = 0;
		restore_flag = 0;

		$;
		
		if (skip_execute == 0) then // This is a sitaar if
		
			$
			//Execute instruction 
            //Lot of redundant variables are there, lets keep it like this
			dc_out.cache_transactions = 0;
			post_execute_trap_vector = executeInstruction_split_1(thread_state,
							opcode, 
							operand2_0, operand2_1, 
							operand1_0, operand1_1, 
							&result_h, &result_l,
							&flags, rs1, rd, asi, i,
							data1, data0, vector_data_type, 
							&dc_out, &ic_out);
                           
			done_pull = d_done_pull = i_done_pull = 0;
			
			wait_4_cache = ((dc_out.push_done) || (ic_out.push_done));
			
			$;
			
			if (wait_4_cache != 0) then //sitaar if
				do												// sitaar do
					do											// sitaar do
						wait until (this_phase==0);
						$
						if (dc_out.push_done) d_done_pull= d_mae_in.pull(d_mae_token);
						if (ic_out.push_done) i_done_pull= i_mae_in.pull(i_mae_token);
						done_pull = ((dc_out.push_done) && (ic_out.push_done))?(d_done_pull && i_done_pull):\
							(((dc_out.push_done) && d_done_pull) || ((ic_out.push_done) && i_done_pull));
						$;
						if(not done_pull) then wait end if;
					while(not done_pull) end do;   
					wait until (this_phase==1);
						
					$
					if (d_done_pull) memcpy(&dc_out.mae, d_mae_token.data(), sizeof(uint8_t));
					if (i_done_pull) memcpy(&ic_out.mae, i_mae_token.data(), sizeof(uint8_t));
							
					//Lot of redundant variables are there, lets keep it like this
					post_execute_trap_vector |= executeInstruction_split_2(thread_state,
						opcode, 
						operand2_0, operand2_1, 
						operand1_0, operand1_1, 
						&result_h, &result_l,
						&flags, rs1, rd, asi, i,
						data1, data0, vector_data_type, 
						&dc_out, &ic_out);
					
					wait_4_cache = ((dc_out.push_done) || (ic_out.push_done));
					
					$;
								
				while (wait_4_cache != 0) end do;
			end if;
			
			$
			//This trap vector should have been saved in thread state by now
			thread_state->trap_vector = post_execute_trap_vector;
			save_flag = (opcode == _SAVE_);
			restore_flag = (opcode == _RESTORE_);
			$;
		end if;

		$
		uint8_t post_execute_trap = getBit32(thread_state->trap_vector, _TRAP_);


		uint8_t skip_write_back = skip_execute || post_execute_trap || !getBit8(flags, _NEED_WRITE_BACK_);
		if(!skip_write_back)
		{
			writeBackResult(thread_state->register_file, rd, result_h, result_l, flags, getSlice32(thread_state->status_reg.psr, 4, 0), thread_state->status_reg.pc, &(thread_state->reg_update_flags));
		}
       			
		
		if(!skip_fetch && (getBit32(thread_state->trap_vector, _TRAP_)==0))
		{
			increment_instruction_count(thread_state);

			if((save_flag || restore_flag) && thread_state->report_traps)
			{
				fprintf(stderr,"Info: at pc=0x%x, %s.. now fp=0x%x, sp=0x%x, wim=0x%x, psr=0x%x\n", thread_state->status_reg.pc,  (save_flag ? "save" : "restore"),
						frame_pointer(thread_state), stack_pointer(thread_state),
						thread_state->status_reg.wim,
						thread_state->status_reg.psr);
			}
			else if(thread_state->report_traps)
			{
				fprintf(stderr,"Info: at pc=0x%x, now fp=0x%x, sp=0x%x, wim=0x%x, psr=0x%x\n", 
						thread_state->status_reg.pc,  
						frame_pointer(thread_state), stack_pointer(thread_state),
						thread_state->status_reg.wim,
						thread_state->status_reg.psr);
			}

			//if logging is enabled,
			//Compute a signature containing information about
			//processor state updated by this instruction
			//and send it out to the logger.
			//Lets leave this commented for now
			//if(is_logging_enabled())
			//{
			//	generateLogMessage(thread_state);
			//}
		}

		uint8_t update_pc = (!skip_execute || !skip_fp_execute) && !post_execute_trap && !isBranchInstruction(opcode, inst_type);
		if(update_pc)
		{
			thread_state->status_reg.pc = thread_state->status_reg.npc ;
			thread_state->status_reg.npc = thread_state->status_reg.npc + 4 ;
		}
		$;
			
	while(1) end do;

end behavior
end module


module DCACHE
    parameter int CPU_THREADS = 2
	parameter int CORE_ID = 0
	parameter int CACHE_LINES = 512
	parameter int isa_mode = 32
	parameter int bp_table_size = 16
	parameter int ASSOCIATIVITY = 1
    parameter int init_pc = 0

    inport_array	asi[CPU_THREADS] : width 8
    inport_array addr[CPU_THREADS] : width 32
    inport_array request_type[CPU_THREADS] : width 8
    inport_array byte_mask[CPU_THREADS] : width 8
    inport_array write_data[CPU_THREADS] : width 64
    	
    outport_array mae_out[CPU_THREADS] : width 8
    outport_array read_data[CPU_THREADS] : width 64
	
    // D$ <-> MMU
    outport dm_mmu_command: width 8
    outport dm_request_type: width 8
    outport dm_asi: width 8
    outport dm_addr: width 32	
    outport dm_byte_mask: width 8 
    outport dm_write_data: width 64

    inport dm_mae: width 8 
    inport dm_cacheable: width 8 
    inport dm_acc: width 8
    inport dm_read_data: width 64
    inport dm_read_line: width 512
    inport dm_mmu_fsr: width 32
    inport dm_synonym_invalidate_word: width 32

    // Bridge → D$ broadcasts
    inport  br2dc_inv_paddr_line : width 32   // physical line address
    
    include $extern "C" {
		#include "ajit_ng.h"	
        #include "CacheInterfaceS.h"
		// Forward declare the wrapper functions
		extern bool pullword(void *obj, uint32_t *value, bool sync);
		
    }
    $
    
    decl $uint8_t asi_in;$
    decl $uint8_t done_0_pull, done_pull;$
	decl $uint8_t inner_loop_count;$
    decl $WriteThroughAllocateCache *dcache;$
    decl $mmu_out mmu;$
    decl $uint8_t d_request_type, d_byte_mask;$
    decl $uint32_t d_addr;$
    decl $uint64_t d_write_data;$
    decl $token<sizeof(uint8_t)*8> asi_token[CPU_THREADS], mae_in;$           
	decl $uint32_t dcache_invalidate_word, invalidate_va;$
    decl $uint8_t last_mmu_push_count;$
	
behavior
    $
    uint32_t core_id = CORE_ID;
    uint32_t dcache_number_of_lines = CACHE_LINES;  
    uint32_t dcache_associativity = ASSOCIATIVITY;

	last_mmu_push_count = 0;

    
    mmu.mae_port = (void *)&dm_mae;
    mmu.cacheable_port = (void *)&dm_cacheable;
    mmu.acc_port = (void *)&dm_acc;
    mmu.read_data_port = (void *)&dm_read_data;
    mmu.read_line_port = (void *)&dm_read_line;
    mmu.mmu_fsr_port = (void *)&dm_mmu_fsr;
    mmu.synonym_invalidate_word_port = (void *)&dm_synonym_invalidate_word;    
    mmu.mmu_command_port = (void *)&dm_mmu_command;
    mmu.request_type_port = (void *)&dm_request_type;
    mmu.asi_port = (void *)&dm_asi;
    mmu.addr_port = (void *)&dm_addr;	
    mmu.byte_mask_port = (void *)&dm_byte_mask; 
    mmu.write_data_port = (void *)&dm_write_data;

    dcache = makeCache(core_id, 0, dcache_number_of_lines, dcache_associativity);
    
	$;
    
    do
        $
		
        while(pullword((void *)&br2dc_inv_paddr_line, &dcache_invalidate_word, true)) {
			invalidate_va = (dcache_invalidate_word & 0x7fffffff);
			invalidateCacheLine(dcache, invalidate_va);        
        }
        done_0_pull = 0;
		inner_loop_count = 0;
        $;	
		// This will be our arbitration loop. Simple!
		do
			wait until (this_phase==0);
			$done_pull=asi[inner_loop_count].pull(asi_token[inner_loop_count]);$;
			if (done_pull) then
				$
				mmu.mmu_push_count = 0;
				asi_in = *(asi_token[inner_loop_count].data());
				cpuDcacheAccess_pull(&addr[inner_loop_count], &request_type[inner_loop_count], &byte_mask[inner_loop_count], 
								&write_data[inner_loop_count], &d_addr, &d_request_type, &d_byte_mask, &d_write_data);
				$;
				
				do
					$
					last_mmu_push_count = mmu.mmu_push_count;
					cpuDcacheAccess_split_123(dcache, &mmu, asi_in, d_addr, d_request_type, d_byte_mask, 
										d_write_data);
					$;
					if (mmu.mmu_push_count >  last_mmu_push_count) then										
						do 
							$done_0_pull=dm_mae.pull(mae_in);$;
							if(not done_0_pull) then 
								wait 
							else
								$
								mmu.mae = *(mae_in.data());
								mmu_pull(&mmu);
								$;
							end if;
						while (not done_0_pull) end do;	
					end if;
				while(mmu.mmu_push_count >  last_mmu_push_count) end do;
				$
				cpuDCacheAccess_pushback(&mae_out[inner_loop_count], &read_data[inner_loop_count], mmu.mae, mmu.read_data);
				$;
			end if;
			$
			inner_loop_count = inner_loop_count + 1;
			$;
		while(inner_loop_count < CPU_THREADS) end do;
    
	while(1) end do;
	
end behavior

end module

module ICACHE
    parameter int CPU_THREADS = 2
	parameter int CORE_ID = 0
	parameter int CPU_ID = 0
	parameter int isa_mode = 32
	parameter int bp_table_size = 16
	parameter int report_traps = 0
    parameter int init_pc = 0
	parameter int CACHE_LINES = 512
	parameter int ASSOCIATIVITY = 1
    
    inport_array	asi[CPU_THREADS] : width 8
    inport_array addr[CPU_THREADS] : width 32
    inport_array request_type[CPU_THREADS] : width 8
    inport_array byte_mask[CPU_THREADS] : width 8
	
    outport_array mae_out[CPU_THREADS] : width 8
    outport_array inst_pair[CPU_THREADS] : width 64
	outport_array mmu_fsr[CPU_THREADS] : width 32

    // I$ <-> MMU
    
    outport im_mmu_command: width 8
    outport im_request_type: width 8
    outport im_asi: width 8
    outport im_addr: width 32
    outport im_byte_mask: width 8     
    
    inport im_mae: width 8 
    inport im_cacheable: width 8 
    inport im_acc: width 8
    inport im_read_data: width 64
    inport im_read_line: width 512
    inport im_mmu_fsr: width 32
    inport im_synonym_invalidate_word: width 32
    
	// Bridge → I$ broadcasts
    inport  br2ic_inv_paddr_line : width 32   // physical line address

	
    include $extern "C" {
		#include "ajit_ng.h"	
        #include "MmuS.h"
		// Forward declare the wrapper functions
		extern bool pullword(void *obj, uint32_t *value, bool sync);
		
    }
    $
    
    decl $uint8_t asi_in;$
    decl $uint8_t done_0_pull, done_pull;$
	decl $uint8_t inner_loop_count;$
    decl $WriteThroughAllocateCache *icache;$
    decl $mmu_out mmu;$
    decl $uint8_t i_request_type, i_byte_mask;$
    decl $uint32_t i_addr;$
    decl $token<sizeof(uint8_t)*8> asi_token[CPU_THREADS], mae_in;$           
	decl $uint32_t icache_invalidate_word, invalidate_va;$
    decl $uint8_t last_mmu_push_count;$
	
behavior
    $
    uint32_t core_id = CORE_ID;
    uint32_t icache_number_of_lines = CACHE_LINES;  
    uint32_t icache_associativity = ASSOCIATIVITY;

	last_mmu_push_count = 0;

    
    mmu.mae_port = (void *)&im_mae;
    mmu.cacheable_port = (void *)&im_cacheable;
    mmu.acc_port = (void *)&im_acc;
    mmu.read_data_port = (void *)&im_read_data;
    mmu.read_line_port = (void *)&im_read_line;
    mmu.mmu_fsr_port = (void *)&im_mmu_fsr;
    mmu.synonym_invalidate_word_port = (void *)&im_synonym_invalidate_word;    
    mmu.mmu_command_port = (void *)&im_mmu_command;
    mmu.request_type_port = (void *)&im_request_type;
    mmu.asi_port = (void *)&im_asi;
    mmu.addr_port = (void *)&im_addr;	
    mmu.byte_mask_port = (void *)&im_byte_mask; 
    mmu.read_line = 0;

    icache = makeCache(core_id, 1, icache_number_of_lines, icache_associativity); // Make the I Cache now
    
	$;
    
    do
        $
		
        while(pullword((void *)&br2ic_inv_paddr_line, &icache_invalidate_word, true)) {
			invalidate_va = (icache_invalidate_word & 0x7fffffff);
			invalidateCacheLine(icache, invalidate_va);        
        }
        done_0_pull = 0;
		inner_loop_count = 0;
        $;	
		// This will be our arbitration loop. Simple!
		do
			wait until (this_phase==0);
			$done_pull=asi[inner_loop_count].pull(asi_token[inner_loop_count]);$;
			if (done_pull) then
				$
				mmu.mmu_push_count = 0;
				asi_in = *(asi_token[inner_loop_count].data());
				cpuIcacheAccess_pull(&addr[inner_loop_count], &request_type[inner_loop_count], &byte_mask[inner_loop_count], 
								&i_addr, &i_request_type, &i_byte_mask);
				$;
				
				do
					$
					last_mmu_push_count = mmu.mmu_push_count;
					cpuIcacheAccess_split_12(icache, &mmu, asi_in, i_addr, i_request_type, i_byte_mask);
					$;
					if (mmu.mmu_push_count >  last_mmu_push_count) then										
						do 
							$done_0_pull=im_mae.pull(mae_in);$;
							if(not done_0_pull) then 
								wait 
							else
								$
								mmu.mae = *(mae_in.data());
								mmu_pull(&mmu);
								$;
							end if;
						while (not done_0_pull) end do;	
					end if;
				while(mmu.mmu_push_count >  last_mmu_push_count) end do;
				$
				cpuICacheAccess_pushback(&mae_out[inner_loop_count], &inst_pair[inner_loop_count], &mmu_fsr[inner_loop_count], mmu.mae, mmu.read_data, mmu.mmu_fsr);
				$;
			end if;
			$
			inner_loop_count = inner_loop_count + 1;
			$;
		while(inner_loop_count < CPU_THREADS) end do;
    
	while(1) end do;
	
end behavior

end module

// ================================
// MMU — per-core (interfaces only)
// Reuses legacy-style naming (ic2mmu_*, dc2mmu_*, mmu2br_*, br2mmu_*)
// ================================
module MMU

    // I$ <-> MMU
    parameter int CORE_ID = 0
	parameter int DCACHE_LINES = 512
	parameter int DASSOCIATIVITY = 1
	parameter int ICACHE_LINES = 512
	parameter int IASSOCIATIVITY = 1



    inport im_mmu_command: width 8
    inport im_request_type: width 8
    inport im_asi: width 8
    inport im_addr: width 32	
    inport im_byte_mask: width 8 

    outport im_mae: width 8 
    outport im_cacheable: width 8 
    outport im_acc: width 8
    outport im_read_data: width 64
    outport im_read_line: width 512
    outport im_mmu_fsr: width 32
    outport im_synonym_invalidate_word: width 32
            
    // D$ <-> MMU
    inport dm_mmu_command: width 8
    inport dm_request_type: width 8
    inport dm_asi: width 8
    inport dm_addr: width 32
    inport dm_byte_mask: width 8 
    inport dm_write_data: width 64
	
    outport dm_mae: width 8 
    outport dm_cacheable: width 8 
    outport dm_acc: width 8
    outport dm_read_data: width 64
    outport dm_read_line: width 512
    outport dm_mmu_fsr: width 32
    outport dm_synonym_invalidate_word: width 32

    // MMU <-> Bridge
    outport request_type : width 8
    outport byte_mask : width 8
    outport addr : width 32
    outport data64 : width 64
    inport  rdata : width 64

    include $extern "C" {
		#include "ajit_ng.h"	
        #include "rlutS.h"
		// Forward declare the wrapper functions		
    }
    $
    
    decl $uint8_t asi_in;$
    decl $uint8_t done_0_pull, done_pull;$
	decl $uint8_t inner_loop_count, dcache;$
    decl $mmu_in mmu;$
	decl $MmuState *mmu_state;$
    decl $uint8_t mmu_dword_command, request_type_in, byte_mask_in;$
    decl $uint32_t addr_in;$
    decl $uint64_t write_data;$
    decl $token<sizeof(uint8_t)*8> asi_token;$
    decl $token<sizeof(uint64_t)*8> read_data_token;$
    decl $uint8_t last_bridge_push_count;$

behavior

    $
    uint32_t core_id = CORE_ID;

	last_bridge_push_count = 0;

    
    mmu.im_mae_port = (void *)&im_mae;
    mmu.im_cacheable_port = (void *)&im_cacheable;
    mmu.im_acc_port = (void *)&im_acc;
    mmu.im_read_data_port = (void *)&im_read_data;
    mmu.im_read_line_port = (void *)&im_read_line;
    mmu.im_mmu_fsr_port = (void *)&im_mmu_fsr;
    mmu.im_synonym_invalidate_word_port = (void *)&im_synonym_invalidate_word;    
    mmu.im_mmu_command_port = (void *)&im_mmu_command;
    mmu.im_request_type_port = (void *)&im_request_type;
    mmu.im_asi_port = (void *)&im_asi;
    mmu.im_addr_port = (void *)&im_addr;	
    mmu.im_byte_mask_port = (void *)&im_byte_mask; 

    mmu.dm_mae_port = (void *)&dm_mae;
    mmu.dm_cacheable_port = (void *)&dm_cacheable;
    mmu.dm_acc_port = (void *)&dm_acc;
    mmu.dm_read_data_port = (void *)&dm_read_data;
	mmu.dm_write_data_port = (void *)&dm_write_data;
    mmu.dm_read_line_port = (void *)&dm_read_line;
    mmu.dm_mmu_fsr_port = (void *)&dm_mmu_fsr;
    mmu.dm_synonym_invalidate_word_port = (void *)&dm_synonym_invalidate_word;    
    mmu.dm_mmu_command_port = (void *)&dm_mmu_command;
    mmu.dm_request_type_port = (void *)&dm_request_type;
    mmu.dm_asi_port = (void *)&dm_asi;
    mmu.dm_addr_port = (void *)&dm_addr;	
    mmu.dm_byte_mask_port = (void *)&dm_byte_mask; 
    //bridge ports
    mmu.br_request_type_port = (void *)&request_type;
    mmu.br_byte_mask_port = (void *)&byte_mask;
    mmu.br_addr_port = (void *)&addr;
    mmu.br_data64_port = (void *)&data64;
    mmu.br_rdata_port = (void *)&rdata;
	
	mmu.read_line = 0;
    uint32_t icache_number_of_lines = ICACHE_LINES;  
    uint32_t icache_associativity = IASSOCIATIVITY;
    uint32_t dcache_number_of_lines = DCACHE_LINES;  
    uint32_t dcache_associativity = DASSOCIATIVITY;

	mmu_state =  makeMmuState(core_id);
    setupRlutManager(core_id, icache_number_of_lines, icache_associativity, dcache_number_of_lines, dcache_associativity);

	
	$;
	
    do 
	
        $
        done_0_pull = 0;
		inner_loop_count = 0;
        $;	
		// This will be our arbitration loop. Simple!
		do
			wait until (this_phase==0);
			$dcache = inner_loop_count;$;
			$done_pull= (dcache)?dm_asi.pull(asi_token):im_asi.pull(asi_token);$;
			if (done_pull) then
				$
				mmu.bridge_push_count = 0;
				asi_in = *(asi_token.data());
				mmu_cache_pull(&mmu, dcache,  &mmu_dword_command, &request_type_in, &addr_in, &byte_mask_in, &write_data);
				mmu.read_line = (mmu_dword_command == MMU_READ_LINE)? 1:0;
                mmu.mmu_exec_state = MMU_INIT;
				$;
				
				do
					$
					last_bridge_push_count = mmu.bridge_push_count;
					Mmu_split_123(mmu_state, &mmu, mmu_dword_command, request_type_in, asi_in, addr_in, byte_mask_in, write_data);
					$;
					if (mmu.bridge_push_count >  last_bridge_push_count) then										
						do 
							$done_0_pull=rdata.pull(read_data_token);$;
							if(not done_0_pull) then 
								wait 
							else
								$
								*mmu.ptr = *(read_data_token.data());
								$;
							end if;
						while (not done_0_pull) end do;	
					end if;
				while(mmu.bridge_push_count >  last_bridge_push_count) end do;
				$
				mmu_cache_pushback(&mmu, dcache);
				$;
			end if;
			$
			inner_loop_count = inner_loop_count + 1;
			$;
		while(inner_loop_count < 2) end do;	// 2 here means one for dcache and one for icache
	
	
	while(1) end do;

end behavior
end module


// ========================================
// Bridge — single per system (interfaces only)
// Adds invalidate + flush broadcasts to all D$
// ========================================
module Bridge
    parameter int NUM_CPU = 1

    // MMU <-> Bridge
    inport_array request_type[NUM_CPU] : width 8
    inport_array byte_mask[NUM_CPU] : width 8
    inport_array addr[NUM_CPU] : width 32
    inport_array data64[NUM_CPU] : width 64

    outport_array  rdata[NUM_CPU] : width 64
    
    //Bridge <-> Memory
    outport m_address :width 32
    outport double_word: width 64
    outport m_byte_mask: width 8
    
    inport m_data: width 64

	// Bridge → D$ broadcasts
    outport_array  br2dc_inv_paddr_line[NUM_CPU] : width 32   // physical line address
	
	// Bridge → I$ broadcasts
    outport_array  br2ic_inv_paddr_line[NUM_CPU] : width 32   // physical line address
	
behavior
    do wait until (this_phase==1); while(1) end do;
end behavior
end module


// ========================================
// Memory — single per system (interfaces only)
// ========================================
module Memory

    // Bridge -> Memory
    outport m_address :width 32
    outport double_word: width 64
    outport m_byte_mask: width 8
    
    inport m_data: width 64


behavior
    do wait until (this_phase==1); while(1) end do;
end behavior
end module
